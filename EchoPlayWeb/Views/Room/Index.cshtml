@{
    ViewData["Title"] = "Чат комната";
}

<div class="app-container">
    <!-- Основное содержимое страницы будет слева -->
    <div class="content-area">
        <!-- Видео элементы для WebRTC -->
        <div class="video-container">
            <video id="localVideo" autoplay muted playsinline></video>
            <video id="remoteVideo" autoplay playsinline></video>
        </div>
        <div class="device-controls">
            <select id="cameraSelect" class="device-select"></select>
            <select id="microphoneSelect" class="device-select"></select>
        </div>
        <div class="webrtc-controls">
            <button id="startButton">Start Devices</button>
            <button id="callButton" disabled>Call</button>
            <button id="hangupButton" disabled>Hang Up</button>
        </div>
        <div id="onlineUsersContainer" style="display: none;">
            <h3>Online Users:</h3>
            <ul id="onlineUsersList"></ul>
        </div>
        <div id="errorContainer" class="error-message"></div>
    </div>

    <!-- Чат справа -->
    <div class="chat-container">
        <h1>Чат комната: <span id="roomIdDisplay">@ViewData["RoomId"]</span></h1>
        <div class="user-info">Вы вошли как: <span id="currentUserDisplay"></span></div>

        <div class="chat-box">
            <ul id="messagesList" class="message-list"></ul>
            <div class="message-input">
                <input type="text" id="messageInput" placeholder="Введите сообщение..." />
                <button id="sendButton">Отправить</button>
            </div>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.1/signalr.min.js"></script>
<script>
    // Chat room variables
    const roomId = "@ViewData["RoomId"]";
    const currentUser = "User_" + Math.random().toString(36).substring(2, 8);
    const serverUrl = "https://localhost:7222";

    // DOM elements
    const messagesList = document.getElementById("messagesList");
    const messageInput = document.getElementById("messageInput");
    const sendButton = document.getElementById("sendButton");
    const currentUserDisplay = document.getElementById("currentUserDisplay");
    
    // WebRTC elements
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const startButton = document.getElementById('startButton');
    const callButton = document.getElementById('callButton');
    const hangupButton = document.getElementById('hangupButton');
    const onlineUsersList = document.getElementById('onlineUsersList');
    const onlineUsersContainer = document.getElementById('onlineUsersContainer');
    const cameraSelect = document.getElementById('cameraSelect');
    const microphoneSelect = document.getElementById('microphoneSelect');
    const errorContainer = document.getElementById('errorContainer');

    // WebRTC variables
    let localStream;
    let peerConnection;
    let currentCallConnectionId = null;
    const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    // Set current user display
    currentUserDisplay.textContent = currentUser;

    // Initialize SignalR connections
    const chatRoomConnection = new signalR.HubConnectionBuilder()
        .withUrl(`${serverUrl}/chatHub`)
        .configureLogging(signalR.LogLevel.Information)
        .build();

    const webRtcConnection = new signalR.HubConnectionBuilder()
        .withUrl(`${serverUrl}/WebRTCHub`)
        .configureLogging(signalR.LogLevel.Information)
        .build();

    // Chat room handlers (unchanged)
    chatRoomConnection.on("Notify", (message) => addSystemMessage(message));
    chatRoomConnection.on("ReceiveMessage", (user, message, messageId) => addMessageToChat(user, message, messageId));
    chatRoomConnection.on("UpdateMessage", (messageId, newMessage, user) => updateMessageInChat(messageId, newMessage, user));
    chatRoomConnection.on("DeleteMessage", (messageId, user) => deleteMessageFromChat(messageId, user));

    // WebRTC handlers (unchanged)
    webRtcConnection.on("ReceiveSignal", (senderConnectionId, type, data) => {
        if (type === 'offer') {
            handleOffer(senderConnectionId, data);
        } else if (type === 'answer') {
            handleAnswer(data);
        } else if (type === 'candidate') {
            handleCandidate(data);
        }
    });

    webRtcConnection.on("OnlineUsers", (users) => {
        onlineUsersList.innerHTML = '';
        users.forEach(user => {
            if (user !== webRtcConnection.connectionId) {
                const li = document.createElement('li');
                li.textContent = user;
                li.onclick = () => initiateCall(user);
                onlineUsersList.appendChild(li);
            }
        });
        onlineUsersContainer.style.display = 'block';
    });

    // Device management functions
    async function getDevices() {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const cameras = devices.filter(device => device.kind === 'videoinput');
            const microphones = devices.filter(device => device.kind === 'audioinput');
            
            populateSelect(cameraSelect, cameras);
            populateSelect(microphoneSelect, microphones);
            
            return { cameras, microphones };
        } catch (err) {
            showError('Error enumerating devices: ' + err.message);
            return { cameras: [], microphones: [] };
        }
    }

    function populateSelect(selectElement, devices) {
        selectElement.innerHTML = '';
        devices.forEach(device => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.text = device.label || `Unknown ${device.kind} (${device.deviceId.slice(0, 5)}...)`;
            selectElement.appendChild(option);
        });
    }

    async function startLocalStream() {
        try {
            const constraints = {
                video: {
                    deviceId: cameraSelect.value ? { exact: cameraSelect.value } : undefined,
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                },
                audio: microphoneSelect.value ? { deviceId: { exact: microphoneSelect.value } } : true
            };

            // Try with video first
            localStream = await navigator.mediaDevices.getUserMedia(constraints);
            
            // If no video, try audio only
            if (!localStream.getVideoTracks().length) {
                showWarning('Video device not found, continuing with audio only');
                constraints.video = false;
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
            }

            // If no audio either, try without any devices
            if (!localStream.getAudioTracks().length && !localStream.getVideoTracks().length) {
                showWarning('No media devices found. You can still chat without audio/video');
                localStream = null;
                startButton.disabled = true;
                return;
            }

            localVideo.srcObject = localStream;
            startButton.disabled = true;
            callButton.disabled = false;
            await webRtcConnection.invoke("GetOnlineUsers");
            hideError();
        } catch (err) {
            showError('Error accessing media devices: ' + err.message);
            startButton.disabled = false;
        }
    }

    function showError(message) {
        errorContainer.textContent = message;
        errorContainer.style.display = 'block';
    }

    function showWarning(message) {
        addSystemMessage('Warning: ' + message);
    }

    function hideError() {
        errorContainer.style.display = 'none';
    }

    // WebRTC functions (unchanged except for error handling)
    function initiateCall(targetConnectionId) {
        if (!localStream) {
            showError('No local media stream available');
            return;
        }

        try {
            currentCallConnectionId = targetConnectionId;
            createPeerConnection();
            
            peerConnection.createOffer()
                .then(offer => peerConnection.setLocalDescription(offer))
                .then(() => {
                    webRtcConnection.invoke("SendSignal", currentCallConnectionId, "offer", peerConnection.localDescription);
                })
                .catch(err => {
                    showError('Error creating offer: ' + err.message);
                    hangUp();
                });
            
            callButton.disabled = true;
            hangupButton.disabled = false;
        } catch (err) {
            showError('Error initiating call: ' + err.message);
        }
    }

    function createPeerConnection() {
        try {
            peerConnection = new RTCPeerConnection(configuration);
            
            // Add local stream to connection
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });
            }
            
            // Set up remote stream
            peerConnection.ontrack = event => {
                remoteVideo.srcObject = event.streams[0];
            };
            
            // Handle ICE candidates
            peerConnection.onicecandidate = event => {
                if (event.candidate && currentCallConnectionId) {
                    webRtcConnection.invoke("SendSignal", currentCallConnectionId, "candidate", event.candidate);
                }
            };
            
            peerConnection.oniceconnectionstatechange = () => {
                if (peerConnection.iceConnectionState === 'failed') {
                    showError('Connection failed');
                    hangUp();
                }
            };
        } catch (err) {
            showError('Error creating peer connection: ' + err.message);
            throw err;
        }
    }

    function handleOffer(senderConnectionId, offer) {
        try {
            if (!peerConnection) {
                createPeerConnection();
            }
            
            currentCallConnectionId = senderConnectionId;
            
            peerConnection.setRemoteDescription(new RTCSessionDescription(offer))
                .then(() => peerConnection.createAnswer())
                .then(answer => peerConnection.setLocalDescription(answer))
                .then(() => {
                    webRtcConnection.invoke("SendSignal", senderConnectionId, "answer", peerConnection.localDescription);
                })
                .catch(err => {
                    showError('Error handling offer: ' + err.message);
                    hangUp();
                });
            
            callButton.disabled = true;
            hangupButton.disabled = false;
        } catch (err) {
            showError('Error handling offer: ' + err.message);
        }
    }

    function handleAnswer(answer) {
        try {
            peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        } catch (err) {
            showError('Error handling answer: ' + err.message);
        }
    }

    function handleCandidate(candidate) {
        try {
            peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        } catch (err) {
            showError('Error handling ICE candidate: ' + err.message);
        }
    }

    function hangUp() {
        try {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            if (localVideo.srcObject) {
                localVideo.srcObject.getTracks().forEach(track => track.stop());
                localVideo.srcObject = null;
            }
            
            if (remoteVideo.srcObject) {
                remoteVideo.srcObject = null;
            }
            
            currentCallConnectionId = null;
            callButton.disabled = false;
            hangupButton.disabled = true;
            
            // Reset start button if no stream is available
            if (!localStream) {
                startButton.disabled = false;
            }
        } catch (err) {
            showError('Error hanging up: ' + err.message);
        }
    }

    // UI functions (unchanged)
    function addMessageToChat(user, message, messageId) {
        const li = document.createElement("li");
        li.className = "chat-message";
        li.setAttribute("data-message-id", messageId);
        li.innerHTML = `
            <div class="message-header">
                <strong>${user}</strong>
                <div class="message-actions">
                    <button onclick="startEditMessage('${messageId}')">✏️</button>
                    <button onclick="deleteMessage('${messageId}')">🗑️</button>
                </div>
            </div>
            <div id="content-${messageId}">${message}</div>
        `;
        messagesList.appendChild(li);
        scrollToBottom();
    }

    function updateMessageInChat(messageId, newMessage, user) {
        const el = document.getElementById(`content-${messageId}`);
        if (el) {
            el.textContent = newMessage;
            addSystemMessage(`${user} обновил сообщение`);
        }
    }

    function deleteMessageFromChat(messageId, user) {
        const li = document.querySelector(`li[data-message-id="${messageId}"]`);
        if (li) {
            li.remove();
            addSystemMessage(`${user} удалил сообщение`);
        }
    }

    function addSystemMessage(msg) {
        const li = document.createElement("li");
        li.className = "system-message";
        li.textContent = msg;
        messagesList.appendChild(li);
        scrollToBottom();
    }

    function scrollToBottom() {
        messagesList.scrollTop = messagesList.scrollHeight;
    }

    async function sendMessage() {
        const message = messageInput.value.trim();
        if (message && chatRoomConnection.state === signalR.HubConnectionState.Connected) {
            try {
                await chatRoomConnection.invoke("SendMessage", roomId, currentUser, message);
                messageInput.value = "";
            } catch (err) {
                addSystemMessage("Не удалось отправить сообщение");
            }
        }
    }

    async function startEditMessage(messageId) {
        const content = document.getElementById(`content-${messageId}`);
        const currentText = content.textContent;
        content.innerHTML = `
            <input type="text" id="edit-input-${messageId}" value="${currentText}" />
            <button onclick="confirmEdit('${messageId}')">✓</button>
            <button onclick="cancelEdit('${messageId}', '${currentText}')">✕</button>
        `;
    }

    async function confirmEdit(messageId) {
        const newMessage = document.getElementById(`edit-input-${messageId}`).value.trim();
        if (newMessage) {
            await chatRoomConnection.invoke("UpdateMessage", roomId, currentUser, messageId, newMessage);
        }
    }

    function cancelEdit(messageId, originalText) {
        const content = document.getElementById(`content-${messageId}`);
        content.textContent = originalText;
    }

    async function deleteMessage(messageId) {
        if (confirm("Удалить сообщение?")) {
            await chatRoomConnection.invoke("DeleteMessage", roomId, currentUser, messageId);
        }
    }

    // Event listeners
    startButton.addEventListener('click', startLocalStream);
    callButton.addEventListener('click', () => {
        if (currentCallConnectionId) {
            initiateCall(currentCallConnectionId);
        }
    });
    hangupButton.addEventListener('click', hangUp);
    
    sendButton.addEventListener("click", sendMessage);
    messageInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") sendMessage();
    });

    window.addEventListener("beforeunload", async () => {
        try {
            await chatRoomConnection.invoke("LeaveRoom", roomId);
            hangUp();
        } catch {}
    });

    // Make functions global
    window.startEditMessage = startEditMessage;
    window.deleteMessage = deleteMessage;
    window.confirmEdit = confirmEdit;
    window.cancelEdit = cancelEdit;

    // Start connections
    async function startConnections() {
        try {
            await Promise.all([
                chatRoomConnection.start(),
                webRtcConnection.start()
            ]);
            
            await chatRoomConnection.invoke("JoinRoom", roomId);
            addSystemMessage(`Вы присоединились к комнате ${roomId}`);
            
            // Enumerate devices after connections are established
            await getDevices();
        } catch (err) {
            console.error('Connection error:', err);
            addSystemMessage("Ошибка подключения. Повтор через 5 секунд...");
            setTimeout(startConnections, 5000);
        }
    }

    startConnections();
</script>

<style>
    body {
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
        background-color: #f5f5f5;
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }
    
    .app-container {
        display: flex;
        flex: 1;
        min-height: 0; 
    }
    
    /* Основная область контента */
    .content-area {
        flex: 1;
        padding: 20px;
        background-color: #fff;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
    }
    
    .video-container {
        display: flex;
        gap: 20px;
        margin-bottom: 20px;
    }
    
    .video-container video {
        background: #000;
        width: 50%;
        max-height: 300px;
        border-radius: 8px;
    }
    
    .device-controls {
        display: flex;
        gap: 10px;
        margin-bottom: 10px;
    }
    
    .device-select {
        flex: 1;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
    }
    
    .webrtc-controls {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
    }
    
    .webrtc-controls button {
        padding: 8px 16px;
        background: #2c5e9e;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
    }
    
    .webrtc-controls button:disabled {
        background: #ccc;
        cursor: not-allowed;
    }
    
    #onlineUsersList li {
        cursor: pointer;
        padding: 5px;
        margin: 5px 0;
        background: #f0f0f0;
        border-radius: 4px;
    }
    
    #onlineUsersList li:hover {
        background: #e0e0e0;
    }
    
    .error-message {
        color: #d9534f;
        background-color: #f2dede;
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 15px;
        display: none;
    }
    
    /* Стили для чата */
    .chat-container {
        width: 350px;
        display: flex;
        flex-direction: column;
        background-color: #fff;
        border-left: 1px solid #ddd;
        box-shadow: -2px 0 5px rgba(0,0,0,0.1);
        height: calc(100vh - 120px); 
    }
    
    .chat-container h1 {
        font-size: 1.5rem;
        margin: 15px;
        padding-bottom: 15px;
        border-bottom: 1px solid #eee;
        flex-shrink: 0;
    }
    
    .user-info {
        margin: 0 15px 15px;
        font-size: 0.9em;
        color: #555;
        flex-shrink: 0;
    }
    
    .chat-box {
        display: flex;
        flex-direction: column;
        flex: 1;
        min-height: 0;
        padding: 0 15px;
    }

    .message-list {
        flex: 1;
        list-style: none;
        padding: 0;
        margin: 15px 0;
        overflow-y: auto;
        background-color: #fff;
        border: 1px solid #eee;
        border-radius: 4px;
    }
    
    .message-list li {
        padding: 10px;
        border-bottom: 1px solid #eee;
    }
    
    .chat-message {
        background: #f0f0f0;
        padding: 12px;
        border-radius: 6px;
        margin-bottom: 10px;
    }
    
    .message-header {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5px;
    }
    
    .message-header strong {
        color: #2c5e9e;
    }
    
    .message-actions button {
        background: none;
        border: none;
        cursor: pointer;
        margin-left: 5px;
        color: #666;
    }
    
    .message-actions button:hover {
        color: #2c5e9e;
    }
    
    .system-message {
        color: #666;
        font-style: italic;
        font-size: 0.85em;
        text-align: center;
        padding: 5px 0;
    }
    
    .message-input {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
        flex-shrink: 0;
        padding: 10px 0;
    }
    
    #messageInput {
        flex: 1;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
    }
    
    #sendButton {
        padding: 0 20px;
        background: #2c5e9e;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    }
    
    #sendButton:hover {
        background: #1e4b8a;
    }
</style>