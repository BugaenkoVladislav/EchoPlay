@using System.Security.Claims
@using Newtonsoft.Json
@{
    ViewData["Title"] = "–ì—Ä—É–ø–ø–æ–≤–∞—è –≤–∏–¥–µ–æ–∫–æ–Ω—Ñ–µ—Ä–µ–Ω—Ü–∏—è";
    var username = User.FindFirst(ClaimTypes.Name)?.Value;
    var userMail = User.FindFirst(ClaimTypes.Email)?.Value;
}
<link rel="stylesheet" href="~/css/room.css" />
<div class="app-container">
    <!-- –û—Å–Ω–æ–≤–Ω–∞—è –æ–±–ª–∞—Å—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç–∞ -->
    <div class="content-area">
        <!-- –í–∏–¥–µ–æ —ç–ª–µ–º–µ–Ω—Ç—ã -->
        <div class="video-container">
            <div id="remoteVideosContainer" class="remote-videos-grid"></div>
            <div id="audioOnlyIndicator">
                <div class="audio-call-icon">üé§</div>
                <div>–ê—É–¥–∏–æ-–∑–≤–æ–Ω–æ–∫</div>
            </div>
            <div id="noDevicesMessage" class="warning-message" style="display:none;">
                –£—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã. –í—ã –º–æ–∂–µ—Ç–µ –ø—Ä–æ–¥–æ–ª–∂–∞—Ç—å —Ç–µ–∫—Å—Ç–æ–≤—ã–π —á–∞—Ç.
            </div>
            <div id="errorContainer" class="error-message" style="display:none;"></div>
        </div>

        <!-- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞–º–∏ -->
        <div class="device-controls" id="deviceControls" style="display:none;">
            <div class="device-select-group">
                <label for="microphoneSelect">–ú–∏–∫—Ä–æ—Ñ–æ–Ω:</label>
                <select id="microphoneSelect" class="device-select"></select>
                <button id="toggleMicBtn" class="btn btn-mic">–í—ã–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω</button>
            </div>
        </div>

        <!-- –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è -->
        <div class="webrtc-controls">
            <button id="stopBroadcastBtn" class="btn btn-danger" disabled>–ü–æ–∫–∏–Ω—É—Ç—å –∫–æ–º–Ω–∞—Ç—É</button>
        </div>

        <!-- –°—Ç–∞—Ç—É—Å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è -->
        <div id="connectionStatus" class="connection-status">
            <span class="status-indicator"></span>
            <span class="status-text">–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...</span>
        </div>
    </div>

    <!-- –ë–æ–∫–æ–≤–∞—è –ø–∞–Ω–µ–ª—å —á–∞—Ç–∞ -->
    <div class="chat-container">
        <div class="chat-header">
            <h1>–ö–æ–º–Ω–∞—Ç–∞: <span id="roomIdDisplay">@ViewData["RoomId"]</span></h1>
            <div class="user-info">–í—ã –≤–æ—à–ª–∏ –∫–∞–∫: <span id="currentUserDisplay"></span></div>
        </div>

        <div class="chat-box">
            <ul id="messagesList" class="message-list"></ul>
            <div class="message-input">
                <input type="text" id="messageInput" placeholder="–í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ..." />
                <button id="sendButton" class="btn-send">–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
            </div>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.1/signalr.min.js"></script>
<script>
    const roomId = "@ViewData["RoomId"]";
    const currentUser = @Html.Raw(JsonConvert.SerializeObject(username));
    const serverUrl = "https://localhost:7222";
    
    const appState = {
        localStream: null,
        peerConnections: new Map(),
        hasAudioPermission: false,
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],
        isBroadcasting: false,
        currentUserId: null,
        retryCount: 0,
        maxRetries: 5,
        isInitialized: false,
        isMicMuted: false,
        existingUsers: []
    };
    
    const elements = {
        remoteVideosContainer: document.getElementById('remoteVideosContainer'),
        audioOnlyIndicator: document.getElementById('audioOnlyIndicator'),
        noDevicesMessage: document.getElementById('noDevicesMessage'),
        microphoneSelect: document.getElementById('microphoneSelect'),
        deviceControls: document.getElementById('deviceControls'),
        stopBroadcastBtn: document.getElementById('stopBroadcastBtn'),
        messagesList: document.getElementById('messagesList'),
        messageInput: document.getElementById('messageInput'),
        sendButton: document.getElementById('sendButton'),
        currentUserDisplay: document.getElementById('currentUserDisplay'),
        errorContainer: document.getElementById('errorContainer'),
        connectionStatus: document.querySelector('.connection-status'),
        statusText: document.querySelector('.status-text'),
        statusIndicator: document.querySelector('.status-indicator'),
        roomIdDisplay: document.getElementById('roomIdDisplay'),
        toggleMicBtn: document.getElementById('toggleMicBtn')
    };

    // SignalR —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
    const chatRoomConnection = new signalR.HubConnectionBuilder()
        .withUrl(`${serverUrl}/chatHub`)
        .withAutomaticReconnect()
        .configureLogging(signalR.LogLevel.Warning)
        .build();

    const webRtcConnection = new signalR.HubConnectionBuilder()
        .withUrl(`${serverUrl}/webRTCHub`)
        .withAutomaticReconnect()
        .configureLogging(signalR.LogLevel.Warning)
        .build();

    // ==================== –§—É–Ω–∫—Ü–∏–∏ —á–∞—Ç–∞ ====================
    function addSystemMessage(message) {
        const li = document.createElement("li");
        li.className = "system-message";
        li.textContent = message;
        elements.messagesList.appendChild(li);
        scrollToBottom();
    }

    function addChatMessage(user, message, messageId) {
        const li = document.createElement("li");
        li.className = user === currentUser ? "chat-message my-message" : "chat-message";
        li.setAttribute("data-message-id", messageId);
        
        const isCurrentUser = user === currentUser;
        const actions = isCurrentUser ? `
            <div class="message-actions">
                <button onclick="startEditMessage('${messageId}')">‚úèÔ∏è</button>
                <button onclick="deleteMessage('${messageId}')">üóëÔ∏è</button>
            </div>
        ` : '';
        
        li.innerHTML = `
            <div class="message-header">
                ${!isCurrentUser ? `<strong>${user}</strong>` : ''}
                ${actions}
                ${isCurrentUser ? `<strong>${user}</strong>` : ''}
            </div>
            <div id="content-${messageId}">${message}</div>
        `;
        elements.messagesList.appendChild(li);
        scrollToBottom();
    }

    async function sendMessage() {
        const message = elements.messageInput.value.trim();
        if (message && isConnectionReady()) {
            try {
                await chatRoomConnection.invoke("SendMessage", roomId, currentUser, message);
                elements.messageInput.value = "";
            } catch (err) {
                showError("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: " + err.message);
                console.error("–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è:", err);
            }
        }
    }

    // ==================== WebRTC —Ñ—É–Ω–∫—Ü–∏–∏ ====================
    async function requestDeviceAccess() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const devices = await navigator.mediaDevices.enumerateDevices();
            
            appState.hasAudioPermission = devices.some(d => d.kind === 'audioinput' && d.label !== '');
            
            stream.getTracks().forEach(track => track.stop());
            await updateDeviceLists();
            elements.deviceControls.style.display = 'block';
            hideError();

            if (!appState.hasAudioPermission) {
                elements.noDevicesMessage.style.display = 'block';
                return false;
            }

            return true;
        } catch (err) {
            console.error('–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞–º:', err);
            showError('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É. –í—ã –º–æ–∂–µ—Ç–µ –ø—Ä–æ–¥–æ–ª–∂–∞—Ç—å —Ç–µ–∫—Å—Ç–æ–≤—ã–π —á–∞—Ç.');
            elements.noDevicesMessage.style.display = 'block';
            return false;
        }
    }

    async function updateDeviceLists() {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const microphones = devices.filter(d => d.kind === 'audioinput');
            
            populateSelect(elements.microphoneSelect, microphones, '–ú–∏–∫—Ä–æ—Ñ–æ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω');
            elements.microphoneSelect.disabled = microphones.length === 0;

            return { microphones };
        } catch (err) {
            console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤:', err);
            showError('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω–æ–≤');
            return { microphones: [] };
        }
    }

    function populateSelect(selectElement, devices, emptyMessage) {
        selectElement.innerHTML = '';
        
        if (devices.length === 0) {
            const option = document.createElement('option');
            option.text = emptyMessage;
            selectElement.appendChild(option);
            selectElement.disabled = true;
            return;
        }
        
        const defaultOption = document.createElement('option');
        defaultOption.text = '–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é';
        defaultOption.value = '';
        selectElement.appendChild(defaultOption);
        
        devices.forEach(device => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.text = device.label || `–ú–∏–∫—Ä–æ—Ñ–æ–Ω ${device.deviceId.substring(0, 4)}`;
            selectElement.appendChild(option);
        });
        
        selectElement.disabled = false;
    }

    async function startLocalStream() {
        try {
            if (appState.localStream) {
                appState.localStream.getTracks().forEach(track => track.stop());
            }

            const constraints = {
                audio: {
                    deviceId: elements.microphoneSelect.value ? 
                        { exact: elements.microphoneSelect.value } : undefined,
                    enabled: !appState.isMicMuted
                }
            };

            appState.localStream = await navigator.mediaDevices.getUserMedia(constraints);
            updateLocalMicIndicator();
            return true;
        } catch (err) {
            console.error('–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –ø–æ—Ç–æ–∫–∞:', err);
            showError('–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –∞—É–¥–∏–æ–ø–æ—Ç–æ–∫–∞: ' + err.message);
            return false;
        }
    }

    async function toggleMicrophone(enable) {
        if (!appState.localStream) return;
        
        appState.isMicMuted = !enable;
        appState.localStream.getAudioTracks().forEach(track => {
            track.enabled = enable;
        });
        
        elements.toggleMicBtn.textContent = enable ? '–í—ã–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω' : '–í–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω';
        updateLocalMicIndicator();
        
        try {
            debugger
            await webRtcConnection.invoke("SendMicrophoneState", roomId, appState.currentUserId, !enable);
        } catch (err) {
            console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞:', err);
        }
    }

    function updateLocalMicIndicator() {
        const indicator = document.querySelector('.local-mic-indicator');
        if (indicator) {
            indicator.textContent = appState.isMicMuted ? 'üîá' : 'üé§';
        }
    }

    async function startBroadcast() {
        if (!appState.localStream) {
            const success = await startLocalStream();
            if (!success) {
                showError('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É');
                return;
            }
        }

        try {
            appState.isBroadcasting = true;
            elements.stopBroadcastBtn.disabled = false;
            
            await webRtcConnection.invoke("JoinGroup", roomId, currentUser);
            addSystemMessage('–í—ã –ø–æ–¥–∫–ª—é—á–∏–ª–∏—Å—å –∫ –∞—É–¥–∏–æ–∫–æ–Ω—Ñ–µ—Ä–µ–Ω—Ü–∏–∏');
            
            // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞
            const localIndicator = document.createElement('div');
            localIndicator.className = 'local-mic-indicator';
            localIndicator.textContent = appState.isMicMuted ? 'üîá' : 'üé§';
            document.querySelector('.content-area').appendChild(localIndicator);
        } catch (err) {
            console.error('–û—à–∏–±–∫–∞ –Ω–∞—á–∞–ª–∞ —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–∏:', err);
            showError('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: ' + err.message);
            stopBroadcast();
        }
    }

    async function connectToExistingUsers() {
        if (!appState.isBroadcasting) return;
        
        for (const userId of appState.existingUsers) {
            if (userId !== appState.currentUserId && !appState.peerConnections.has(userId)) {
                await createPeerConnection(userId);
            }
        }
    }

    async function createPeerConnection(targetUserId) {
        try {
            if (appState.peerConnections.has(targetUserId)) {
                return;
            }

            console.log(`–°–æ–∑–¥–∞–Ω–∏–µ PeerConnection –¥–ª—è ${targetUserId}`);
            
            const peerConnection = new RTCPeerConnection({ 
                iceServers: appState.iceServers,
                sdpSemantics: 'unified-plan'
            });
            
            if (appState.localStream) {
                appState.localStream.getAudioTracks().forEach(track => {
                    peerConnection.addTrack(track, appState.localStream);
                });
            }

            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    webRtcConnection.invoke("SendSignal", roomId, appState.currentUserId, "candidate", {
                        targetId: targetUserId,
                        candidate: event.candidate
                    }).catch(err => {
                        console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ ICE candidate:', err);
                    });
                }
            };
            
            peerConnection.oniceconnectionstatechange = () => {
                console.log(`ICE —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è ${targetUserId}:`, peerConnection.iceConnectionState);
                if (peerConnection.iceConnectionState === 'failed') {
                    console.log(`–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å ${targetUserId} –ø—Ä–µ—Ä–≤–∞–Ω–æ`);
                    setTimeout(() => createPeerConnection(targetUserId), 2000);
                }
            };
            
            peerConnection.ontrack = event => {
                if (!event.streams || event.streams.length === 0) return;
                console.log(`–ü–æ–ª—É—á–µ–Ω –∞—É–¥–∏–æ–ø–æ—Ç–æ–∫ –æ—Ç ${targetUserId}`);
                addRemoteVideo(targetUserId, event.streams[0]);
            };

            const offer = await peerConnection.createOffer({
                offerToReceiveAudio: true
            });
            await peerConnection.setLocalDescription(offer);
            
            await webRtcConnection.invoke("SendSignal", roomId, appState.currentUserId, "offer", {
                targetId: targetUserId,
                offer: peerConnection.localDescription
            });
            
            appState.peerConnections.set(targetUserId, peerConnection);
            
        } catch (err) {
            console.error(`–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å ${targetUserId}:`, err);
            removePeerConnection(targetUserId);
        }
    }

    async function handleOffer(senderUserId, data) {
        try {
            if (!appState.localStream) {
                const success = await startLocalStream();
                if (!success) {
                    console.error('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å –ª–æ–∫–∞–ª—å–Ω—ã–π –ø–æ—Ç–æ–∫ –¥–ª—è –æ—Ç–≤–µ—Ç–∞ –Ω–∞ offer');
                    return;
                }
            }
            
            if (appState.peerConnections.has(senderUserId)) {
                console.log(`–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å ${senderUserId} —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç`);
                return;
            }

            console.log(`–û–±—Ä–∞–±–æ—Ç–∫–∞ offer –æ—Ç ${senderUserId}`);

            const peerConnection = new RTCPeerConnection({ 
                iceServers: appState.iceServers,
                sdpSemantics: 'unified-plan'
            });
            
            if (appState.localStream) {
                appState.localStream.getAudioTracks().forEach(track => {
                    peerConnection.addTrack(track, appState.localStream);
                });
            }

            peerConnection.onicecandidate = async event => {
                if (event.candidate) {
                    await webRtcConnection.invoke("SendSignal", roomId, appState.currentUserId, "candidate", {
                        targetId: senderUserId,
                        candidate: event.candidate
                    }).catch(err => {
                        console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ ICE candidate:', err);
                    });
                }
            };
            
            peerConnection.ontrack = event => {
                if (!event.streams || event.streams.length === 0) return;
                console.log(`–ü–æ–ª—É—á–µ–Ω –∞—É–¥–∏–æ–ø–æ—Ç–æ–∫ –æ—Ç ${senderUserId}`);
                addRemoteVideo(senderUserId, event.streams[0]);
            };

            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            
            await webRtcConnection.invoke("SendSignal", roomId, appState.currentUserId, "answer", {
                targetId: senderUserId,
                answer: peerConnection.localDescription
            });
            
            appState.peerConnections.set(senderUserId, peerConnection);
            
        } catch (err) {
            console.error(`–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –æ—Ç ${senderUserId}:`, err);
            removePeerConnection(senderUserId);
        }
    }

    async function addRemoteVideo(userId, stream) {
        const existingVideo = document.getElementById(`remoteVideo-${userId}`);
        if (existingVideo) {
            existingVideo.srcObject = stream;
            return;
        }

        const videoContainer = document.createElement('div');
        videoContainer.className = 'remote-video-container';
        videoContainer.id = `remoteContainer-${userId}`;
        
        const video = document.createElement('video');
        video.id = `remoteVideo-${userId}`;
        video.autoplay = true;
        video.playsInline = true;
        video.srcObject = stream;

        const micIndicator = document.createElement('div');
        micIndicator.className = 'mic-state-indicator';
        micIndicator.textContent = 'üé§';
        
        const userIdLabel = document.createElement('div');
        userIdLabel.className = 'remote-user-id';
        const userName = await webRtcConnection.invoke("GetUsername", userId);
        userIdLabel.textContent = userName;
        getUserPhoto(userName).then(photo => {
            if (photo) {
                console.log("–§–æ—Ç–æ –ø–æ–ª—É—á–µ–Ω–æ:", photo);
                const img = document.createElement('img');
                img.src = photo;
                img.className = 'user-avatar';
                videoContainer.appendChild(img);
                document.getElementById("user-avatar").src = photo;
            } else {
                console.log("–§–æ—Ç–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ");
                videoContainer.appendChild(video);
            }
        });
        
        videoContainer.appendChild(userIdLabel);
        videoContainer.appendChild(micIndicator);
        elements.remoteVideosContainer.appendChild(videoContainer);
    }
    async function getUserPhoto(username) {
        try {
            const response = await fetch(`/Room/GetUserPhoto?username=${encodeURIComponent(username)}`, {
                credentials: 'include'
            });

            if (!response.ok) {
                throw new Error(`–û—à–∏–±–∫–∞: ${response.status}`);
            }
            
            const contentType = response.headers.get('Content-Type');

            if (contentType.includes('application/json')) {
                const jsonData = await response.json();
                console.log("Server response:", jsonData);
                
                return jsonData; 
                
            } else if (contentType.includes('image/')) {
                const photoData = await response.blob();
                return URL.createObjectURL(photoData);
            } else {
                throw new Error("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –æ—Ç–≤–µ—Ç–∞");
            }
        } catch (error) {
            console.error("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–æ—Ç–æ:", error);
            return null;
        }
    }

    function removePeerConnection(userId) {
        console.log(`–£–¥–∞–ª–µ–Ω–∏–µ PeerConnection –¥–ª—è ${userId}`);
        
        const peerConnection = appState.peerConnections.get(userId);
        if (peerConnection) {
            peerConnection.close();
            appState.peerConnections.delete(userId);
        }
        
        const videoContainer = document.getElementById(`remoteContainer-${userId}`);
        if (videoContainer) videoContainer.remove();
    }

    function stopBroadcast() {
        try {
            appState.isBroadcasting = false;
            elements.stopBroadcastBtn.disabled = true;
            
            appState.peerConnections.forEach((pc, userId) => {
                pc.close();
                removePeerConnection(userId);
            });
            
            appState.peerConnections.clear();
            
            if (appState.localStream) {
                appState.localStream.getTracks().forEach(track => track.stop());
                appState.localStream = null;
            }
            
            webRtcConnection.invoke("LeaveGroup", roomId).catch(err => {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ –∏–∑ –≥—Ä—É–ø–ø—ã:', err);
            });
            
            addSystemMessage('–í—ã –ø–æ–∫–∏–Ω—É–ª–∏ –∞—É–¥–∏–æ–∫–æ–Ω—Ñ–µ—Ä–µ–Ω—Ü–∏—é');
            
            // –£–¥–∞–ª—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞
            const localIndicator = document.querySelector('.local-mic-indicator');
            if (localIndicator) localIndicator.remove();
            
            setTimeout(() => {
                window.location.href = '/';
            }, 1000);
        } catch (err) {
            console.error('–û—à–∏–±–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–∏:', err);
            showError('–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ –∏–∑ –∫–æ–º–Ω–∞—Ç—ã: ' + err.message);
        }
    }

    // ==================== –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ====================
    function isConnectionReady() {
        return webRtcConnection.state === signalR.HubConnectionState.Connected && 
               chatRoomConnection.state === signalR.HubConnectionState.Connected;
    }

    function showError(message) {
        console.error(message);
        elements.errorContainer.textContent = message;
        elements.errorContainer.style.display = 'block';
        
        setTimeout(() => {
            elements.errorContainer.style.display = 'none';
        }, 5000);
    }

    function hideError() {
        elements.errorContainer.style.display = 'none';
    }

    function scrollToBottom() {
        elements.messagesList.scrollTop = elements.messagesList.scrollHeight;
    }

    function updateConnectionStatus(isConnected) {
        elements.statusIndicator.className = isConnected ? 'status-indicator connected' : 'status-indicator disconnected';
        elements.statusText.textContent = isConnected ? '–ü–æ–¥–∫–ª—é—á–µ–Ω–æ' : '–û—Ç–∫–ª—é—á–µ–Ω–æ';
    }

    // ==================== –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π ====================
    function setupEventListeners() {
        elements.microphoneSelect.addEventListener('change', async () => {
            if (appState.localStream) {
                await startLocalStream();
            }
        });

        elements.toggleMicBtn.addEventListener('click', () => {
            toggleMicrophone(appState.isMicMuted);
        });

        elements.stopBroadcastBtn.addEventListener('click', stopBroadcast);

        elements.sendButton.addEventListener("click", sendMessage);
        elements.messageInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter") sendMessage();
        });

        window.addEventListener("beforeunload", async () => {
            try {
                if (appState.isBroadcasting) {
                    await webRtcConnection.invoke("LeaveGroup", roomId);
                }
                await chatRoomConnection.invoke("LeaveRoom", currentUser, roomId);
            } catch (err) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏:', err);
            }
        });
    }

    // ==================== –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ====================
    async function initialize() {
        if (appState.isInitialized) return;
        appState.isInitialized = true;

        elements.currentUserDisplay.textContent = currentUser;
        elements.roomIdDisplay.textContent = roomId;

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ SignalR –¥–ª—è —á–∞—Ç–∞
        chatRoomConnection.on("Notify", (message) => {
            addSystemMessage(message);
        });

        chatRoomConnection.on("ReceiveMessage", (user, message, messageId) => {
            addChatMessage(user, message, messageId);
        });

        chatRoomConnection.on("UpdateMessage", (messageId, newMessage, user) => {
            const el = document.getElementById(`content-${messageId}`);
            if (el) el.textContent = newMessage;
        });

        chatRoomConnection.on("DeleteMessage", (messageId, user) => {
            const li = document.querySelector(`li[data-message-id="${messageId}"]`);
            if (li) li.remove();
        });

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ SignalR –¥–ª—è WebRTC
        webRtcConnection.on("ReceiveSignal", async (senderUserId, type, data) => {
            try {
                if (senderUserId === appState.currentUserId) return;

                console.log(`–ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª ${type} –æ—Ç ${senderUserId}`);

                if (type === 'offer') {
                    await handleOffer(senderUserId, data);
                } 
                else if (type === 'answer') {
                    const pc = appState.peerConnections.get(senderUserId);
                    if (pc) await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                } 
                else if (type === 'candidate') {
                    const pc = appState.peerConnections.get(senderUserId);
                    if (pc) await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                }
            } catch (err) {
                console.error('–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–∏–≥–Ω–∞–ª–∞:', err);
            }
        });

        webRtcConnection.on("ExistingUsers", (users) => {
            appState.existingUsers = users;
            connectToExistingUsers();
        });

        webRtcConnection.on("UserJoined", (userId) => {
            if (userId !== appState.currentUserId && appState.isBroadcasting) {
                createPeerConnection(userId);
            }
        });

        webRtcConnection.on("UserLeft", (userId) => {
            removePeerConnection(userId);
            addSystemMessage(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${userId} –ø–æ–∫–∏–Ω—É–ª –∫–æ–Ω—Ñ–µ—Ä–µ–Ω—Ü–∏—é`);
        });

        webRtcConnection.on("ReceiveMicrophoneState", (userId, isMuted) => {
            const videoContainer = document.getElementById(`remoteContainer-${userId}`);
            if (videoContainer) {
                const indicator = videoContainer.querySelector('.mic-state-indicator');
                if (indicator) {
                    indicator.textContent = isMuted ? 'üîá' : 'üé§';
                }
            }
        });

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
        const handleConnectionState = (connection, connectionName) => {
            connection.onreconnecting(() => {
                updateConnectionStatus(false);
                addSystemMessage(`–ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ ${connectionName}...`);
            });

            connection.onreconnected(() => {
                updateConnectionStatus(true);
                addSystemMessage(`–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å ${connectionName} –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ`);
                
                if (connection === webRtcConnection && appState.isBroadcasting) {
                    webRtcConnection.invoke("JoinGroup", roomId,currentUser).catch(err => {
                        console.error("–û—à–∏–±–∫–∞ –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∫ –≥—Ä—É–ø–ø–µ:", err);
                    });
                }
            });

            connection.onclose(() => {
                updateConnectionStatus(false);
                addSystemMessage(`–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å ${connectionName} –ø–æ—Ç–µ—Ä—è–Ω–æ. –ü–æ–ø—ã—Ç–∫–∞ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è...`);
            });
        };

        handleConnectionState(chatRoomConnection, "—á–∞—Ç–æ–º");
        handleConnectionState(webRtcConnection, "WebRTC");

        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
        window.startEditMessage = async function(messageId) {
            const content = document.getElementById(`content-${messageId}`);
            const currentText = content.textContent;
            content.innerHTML = `
                <input type="text" id="edit-input-${messageId}" value="${currentText}" />
                <button onclick="confirmEdit('${messageId}')">‚úì</button>
                <button onclick="cancelEdit('${messageId}', '${currentText}')">‚úï</button>
            `;
            document.getElementById(`edit-input-${messageId}`).focus();
        };

        window.confirmEdit = async function(messageId) {
            const newMessage = document.getElementById(`edit-input-${messageId}`).value.trim();
            if (newMessage) {
                try {
                    await chatRoomConnection.invoke("UpdateMessage", roomId, currentUser, messageId, newMessage);
                } catch (err) {
                    showError("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: " + err.message);
                }
            }
        };

        window.cancelEdit = function(messageId, originalText) {
            const content = document.getElementById(`content-${messageId}`);
            content.textContent = originalText;
        };

        window.deleteMessage = async function(messageId) {
            if (confirm("–£–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ?")) {
                try {
                    await chatRoomConnection.invoke("DeleteMessage", roomId, currentUser, messageId);
                } catch (err) {
                    showError("–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: " + err.message);
                }
            }
        };
        
        setupEventListeners();
        
        try {
            await Promise.all([
                chatRoomConnection.start(),
                webRtcConnection.start()
            ]);
            
            appState.currentUserId = webRtcConnection.connectionId;
            await chatRoomConnection.invoke("JoinRoom",currentUser, roomId);
            updateConnectionStatus(true);
            
            addSystemMessage(`–í—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª–∏—Å—å –∫ –∫–æ–º–Ω–∞—Ç–µ ${roomId}`);
            
            const hasDevices = await requestDeviceAccess();
            if (hasDevices) {
                await startLocalStream();
                await startBroadcast();
            }
        } catch (err) {
            console.error('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏:', err);
            addSystemMessage("–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è. –ü–æ–≤—Ç–æ—Ä —á–µ—Ä–µ–∑ 5 —Å–µ–∫—É–Ω–¥...");
            
            if (appState.retryCount < appState.maxRetries) {
                appState.retryCount++;
                setTimeout(initialize, 5000);
            } else {
                showError("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±–Ω–æ–≤–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É.");
            }
        }
    }

    // –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
    document.addEventListener('DOMContentLoaded', initialize);
</script>
